<!doctype html>

<!--[if lt IE 7]><html lang="en-GB" xmlns:og="http://ogp.me/ns#" xmlns:fb="http://ogp.me/ns/fb#" class="no-js lt-ie9 lt-ie8 lt-ie7"><![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html lang="en-GB" xmlns:og="http://ogp.me/ns#" xmlns:fb="http://ogp.me/ns/fb#" class="no-js lt-ie9 lt-ie8"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html lang="en-GB" xmlns:og="http://ogp.me/ns#" xmlns:fb="http://ogp.me/ns/fb#" class="no-js lt-ie9"><![endif]-->
<!--[if gt IE 8]><!--> <html lang="en-GB" xmlns:og="http://ogp.me/ns#" xmlns:fb="http://ogp.me/ns/fb#" class="no-js"><!--<![endif]-->

	<head>
		<meta charset="utf-8">

				<meta http-equiv="X-UA-Compatible" content="IE=edge">

		<title>Inside the Algolia Engine Part 3 — Query Processing - Milliseconds Matter</title>

				<meta name="HandheldFriendly" content="True">
		<meta name="MobileOptimized" content="320">
		<meta name="viewport" content="width=device-width, initial-scale=0.75, maximum-scale=0.75"/>

				<link rel="apple-touch-icon" href="https://blog.algolia.com/wp-content/themes/algolia/library/images/apple-touch-icon.png">
		<link rel="icon" href="https://blog.algolia.com/wp-content/themes/algolia/favicon.png">
		<!--[if IE]>
			<link rel="shortcut icon" href="https://blog.algolia.com/wp-content/themes/algolia/favicon.ico">
		<![endif]-->
				<meta name="msapplication-TileColor" content="#f01d4f">
		<meta name="msapplication-TileImage" content="https://blog.algolia.com/wp-content/themes/algolia/library/images/win8-tile-icon.png">
    <meta name="theme-color" content="#121212">

		<link rel="pingback" href="https://blog.algolia.com/xmlrpc.php">

        
<!-- This site is optimized with the Yoast SEO plugin v4.5 - https://yoast.com/wordpress/plugins/seo/ -->

<!-- / Yoast SEO plugin. -->

<link rel='dns-prefetch' href='//s0.wp.com' />
<link rel='dns-prefetch' href='//fonts.googleapis.com' />
<link rel='dns-prefetch' href='//s.w.org' />
<link rel="alternate" type="application/rss+xml" title="Milliseconds Matter &raquo; Feed" href="https://blog.algolia.com/feed/" />
<link rel="alternate" type="application/rss+xml" title="Milliseconds Matter &raquo; Comments Feed" href="https://blog.algolia.com/comments/feed/" />
<link rel="alternate" type="application/rss+xml" title="Milliseconds Matter &raquo; Inside the Algolia Engine Part 3 — Query Processing Comments Feed" href="https://blog.algolia.com/inside-the-algolia-engine-part-3-query-processing/feed/" />
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.2.1\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.2.1\/svg\/","svgExt":".svg","source":{"concatemoji":"https:\/\/blog.algolia.com\/wp-includes\/js\/wp-emoji-release.min.js"}};
			!function(a,b,c){function d(a){var b,c,d,e,f=String.fromCharCode;if(!k||!k.fillText)return!1;switch(k.clearRect(0,0,j.width,j.height),k.textBaseline="top",k.font="600 32px Arial",a){case"flag":return k.fillText(f(55356,56826,55356,56819),0,0),!(j.toDataURL().length<3e3)&&(k.clearRect(0,0,j.width,j.height),k.fillText(f(55356,57331,65039,8205,55356,57096),0,0),b=j.toDataURL(),k.clearRect(0,0,j.width,j.height),k.fillText(f(55356,57331,55356,57096),0,0),c=j.toDataURL(),b!==c);case"emoji4":return k.fillText(f(55357,56425,55356,57341,8205,55357,56507),0,0),d=j.toDataURL(),k.clearRect(0,0,j.width,j.height),k.fillText(f(55357,56425,55356,57341,55357,56507),0,0),e=j.toDataURL(),d!==e}return!1}function e(a){var c=b.createElement("script");c.src=a,c.defer=c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g,h,i,j=b.createElement("canvas"),k=j.getContext&&j.getContext("2d");for(i=Array("flag","emoji4"),c.supports={everything:!0,everythingExceptFlag:!0},h=0;h<i.length;h++)c.supports[i[h]]=d(i[h]),c.supports.everything=c.supports.everything&&c.supports[i[h]],"flag"!==i[h]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[i[h]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel='stylesheet' id='wp-quicklatex-format-css'  href='https://blog.algolia.com/wp-content/plugins/wp-quicklatex/css/quicklatex-format.css' type='text/css' media='all' />
<link rel='stylesheet' id='jquery-ui-css'  href='https://blog.algolia.com/wp-content/plugins/algoliasearch-wordpress-master/lib/jquery/jquery-ui.min.css' type='text/css' media='all' />
<link rel='stylesheet' id='algolia_styles-css'  href='https://blog.algolia.com/wp-content/plugins/algoliasearch-wordpress-master/themes/algolia/styles.css' type='text/css' media='all' />
<link rel='stylesheet' id='cresta-social-crestafont-css'  href='https://blog.algolia.com/wp-content/plugins/cresta-social-share-counter/css/csscfont.css' type='text/css' media='all' />
<link rel='stylesheet' id='cresta-social-wp-style-css'  href='https://blog.algolia.com/wp-content/plugins/cresta-social-share-counter/css/cresta-wp-css.css' type='text/css' media='all' />
<link rel='stylesheet' id='cresta-social-googlefonts-css'  href='//fonts.googleapis.com/css?family=Noto+Sans:400,700' type='text/css' media='all' />
<link rel='stylesheet' id='googleFonts-css'  href='//fonts.googleapis.com/css?family=Raleway%3A400%2C600%2C700' type='text/css' media='all' />
<link rel='stylesheet' id='custom-algolia-scripts-css'  href='https://blog.algolia.com/wp-content/themes/algolia/style.css' type='text/css' media='all' />
<link rel='stylesheet' id='bones-stylesheet-css'  href='https://blog.algolia.com/wp-content/themes/algolia/library/css/style.css' type='text/css' media='all' />
<!--[if lt IE 9]>
<link rel='stylesheet' id='bones-ie-only-css'  href='https://blog.algolia.com/wp-content/themes/algolia/library/css/ie.css' type='text/css' media='all' />
<![endif]-->
<link rel='stylesheet' id='jetpack_css-css'  href='https://blog.algolia.com/wp-content/plugins/jetpack/css/jetpack.css' type='text/css' media='all' />
<script type='text/javascript' src='https://blog.algolia.com/wp-includes/js/jquery/jquery.js'></script>
<script type='text/javascript' src='https://blog.algolia.com/wp-includes/js/jquery/jquery-migrate.min.js'></script>
<script type='text/javascript'>
/* <![CDATA[ */
var settings = [];
/* ]]> */
</script>
<script type='text/javascript' src='https://blog.algolia.com/wp-content/plugins/algoliasearch-wordpress-master/lib/jquery/jquery-ui.js'></script>
<script type='text/javascript'>
/* <![CDATA[ */
var settings = [];
/* ]]> */
</script>
<script type='text/javascript' src='https://blog.algolia.com/wp-content/plugins/algoliasearch-wordpress-master/lib/algolia/algoliasearch.min.js'></script>
<script type='text/javascript'>
/* <![CDATA[ */
var settings = [];
/* ]]> */
</script>
<script type='text/javascript' src='https://blog.algolia.com/wp-content/plugins/algoliasearch-wordpress-master/lib/hogan/hogan.js'></script>
<script type='text/javascript'>
/* <![CDATA[ */
var settings = [];
/* ]]> */
</script>
<script type='text/javascript' src='https://blog.algolia.com/wp-content/plugins/algoliasearch-wordpress-master/lib/typeahead/typeahead.js'></script>
<script type='text/javascript'>
/* <![CDATA[ */
var algoliaSettings = {"app_id":"latency","search_key":"6be0576ff61c053d5f9a3225e2a90f76","indices":[{"index_name":"wordpress_post","name":"Articles","order1":0,"order2":0}],"sorting_indices":[{"index_name":"wordpress_all_date_desc","label":""}],"index_name":"wordpress_","type_of_search":["instant"],"instant_jquery_selector":".algoliasearchcontainer","facets":[{"tax":"category","name":"","order":"19","type":"menu"}],"number_by_type":"3","number_by_page":"12","search_input_selector":"[name='s']","plugin_url":"https:\/\/blog.algolia.com\/wp-content\/plugins\/algoliasearch-wordpress-master\/","theme":{"dir":"algolia","name":"New Algolia","screenshot":"https:\/\/blog.algolia.com\/wp-content\/plugins\/algoliasearch-wordpress-master\/core\/..\/themes\/algolia\/screenshot.png","screenshot_autocomplete":"https:\/\/blog.algolia.com\/wp-content\/plugins\/algoliasearch-wordpress-master\/core\/..\/themes\/algolia\/screenshot.png","description":"","facet_types":{"menu":"Menu"}}};
var searchState = {"page":"1"};
/* ]]> */
</script>
<script type='text/javascript' src='https://blog.algolia.com/wp-content/plugins/algoliasearch-wordpress-master/front/main.js'></script>
<script type='text/javascript'>
/* <![CDATA[ */
var themesSettings = [];
/* ]]> */
</script>
<script type='text/javascript' src='https://blog.algolia.com/wp-content/plugins/algoliasearch-wordpress-master/themes/algolia/theme.js'></script>
<script type='text/javascript' src='https://blog.algolia.com/wp-content/themes/algolia/library/js/libs/modernizr.custom.min.js'></script>
<script type='text/javascript' src='https://blog.algolia.com/wp-content/plugins/wp-quicklatex/js/wp-quicklatex-frontend.js'></script>
<link rel='https://api.w.org/' href='https://blog.algolia.com/wp-json/' />
<link rel='shortlink' href='https://blog.algolia.com/?p=5067' />
<link rel="alternate" type="application/json+oembed" href="https://blog.algolia.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fblog.algolia.com%2Finside-the-algolia-engine-part-3-query-processing%2F" />
<link rel="alternate" type="text/xml+oembed" href="https://blog.algolia.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fblog.algolia.com%2Finside-the-algolia-engine-part-3-query-processing%2F&#038;format=xml" />
<style type='text/css'>
			@media (max-width : 640px) {
				#crestashareicon {
					display:none !important;
				}
			}
		#crestashareicon {position:fixed; top:30%; right:20px; float:left;z-index:99;}

		#crestashareicon .sbutton {clear:both;display:none;}
		#crestashareicon .sbutton {float:right;}.cresta-share-icon.first_style .cresta-the-count {left: -11px;}#crestashareiconincontent {float: none; margin: 0 auto; display: table;}</style><script type="text/javascript">
(function(url){
	if(/(?:Chrome\/26\.0\.1410\.63 Safari\/537\.31|WordfenceTestMonBot)/.test(navigator.userAgent)){ return; }
	var addEvent = function(evt, handler) {
		if (window.addEventListener) {
			document.addEventListener(evt, handler, false);
		} else if (window.attachEvent) {
			document.attachEvent('on' + evt, handler);
		}
	};
	var removeEvent = function(evt, handler) {
		if (window.removeEventListener) {
			document.removeEventListener(evt, handler, false);
		} else if (window.detachEvent) {
			document.detachEvent('on' + evt, handler);
		}
	};
	var evts = 'contextmenu dblclick drag dragend dragenter dragleave dragover dragstart drop keydown keypress keyup mousedown mousemove mouseout mouseover mouseup mousewheel scroll'.split(' ');
	var logHuman = function() {
		var wfscr = document.createElement('script');
		wfscr.type = 'text/javascript';
		wfscr.async = true;
		wfscr.src = url + '&r=' + Math.random();
		(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(wfscr);
		for (var i = 0; i < evts.length; i++) {
			removeEvent(evts[i], logHuman);
		}
	};
	for (var i = 0; i < evts.length; i++) {
		addEvent(evts[i], logHuman);
	}
})('//blog.algolia.com/?wordfence_logHuman=1&hid=4D76C86EF89A7980DD48605356AA2F38');
</script>		<style>
		.gist table {
			margin-bottom: 0 !important;
			table-layout: auto !important;
		}
		.gist .line-numbers
		{
			width: 4em !important;
		}
		.gist .line,
		.gist .line-number
		{
			font-size: 12px !important;
			height: 18px !important;
			line-height: 18px !important;
		}
		.gist .line
		{
			white-space: pre !important;
			width: auto !important;
			word-wrap: normal !important;
		}
		.gist .line span
		{
			word-wrap: normal !important;
		}
		</style>
		<style type='text/css'>img#wpstats{display:none}</style><style type="text/css" id="custom-background-css">
body.custom-background { background-color: #ffffff; }
</style>

<!-- START - Facebook Open Graph, Google+ and Twitter Card Tags 2.0.8 -->
 <!-- Facebook Open Graph -->
  <meta property="og:locale" content="en_GB"/>
  <meta property="og:site_name" content="Milliseconds Matter"/>
  <meta property="og:title" content="Inside the Algolia Engine Part 3 — Query Processing"/>
  <meta property="og:url" content="https://blog.algolia.com/inside-the-algolia-engine-part-3-query-processing/"/>
  <meta property="og:type" content="article"/>
  <meta property="og:description" content="Search engines and query processing are not recent in Computer Science: this field known as Information Retrieval has a pretty vast set of state of the art practices. Today most search engines on the market come with a large set of features that developers can use to create their query processing pi"/>
  <meta property="og:image" content="https://blog.algolia.com/wp-content/uploads/2016/05/inside-part-3.png"/>
  <meta property="article:published_time" content="2016-05-24T11:53:42+00:00"/>
  <meta property="article:modified_time" content="2017-04-21T03:57:08+00:00" />
  <meta property="og:updated_time" content="2017-04-21T03:57:08+00:00" />
  <meta property="article:section" content="Technology"/>
 <!-- Google+ / Schema.org -->
  <meta itemprop="name" content="Inside the Algolia Engine Part 3 — Query Processing"/>
  <meta itemprop="description" content="Search engines and query processing are not recent in Computer Science: this field known as Information Retrieval has a pretty vast set of state of the art practices. Today most search engines on the market come with a large set of features that developers can use to create their query processing pi"/>
  <meta itemprop="image" content="https://blog.algolia.com/wp-content/uploads/2016/05/inside-part-3.png"/>
 <!-- Twitter Cards -->
  <meta name="twitter:title" content="Inside the Algolia Engine Part 3 — Query Processing"/>
  <meta name="twitter:url" content="https://blog.algolia.com/inside-the-algolia-engine-part-3-query-processing/"/>
  <meta name="twitter:description" content="Search engines and query processing are not recent in Computer Science: this field known as Information Retrieval has a pretty vast set of state of the art practices. Today most search engines on the market come with a large set of features that developers can use to create their query processing pi"/>
  <meta name="twitter:image" content="https://blog.algolia.com/wp-content/uploads/2016/05/inside-part-3.png"/>
  <meta name="twitter:card" content="summary_large_image"/>
  <meta name="twitter:site" content="@algolia"/>
 <!-- SEO -->
 <!-- Misc. tags -->
<!-- END - Facebook Open Graph, Google+ and Twitter Card Tags 2.0.8 -->

    
        <link rel="stylesheet" href="https://blog.algolia.com/wp-content/themes/algolia/library/css/icons.css">

	</head>

	<body class="post-template-default single single-post postid-5067 single-format-standard custom-background" itemscope itemtype="http://schema.org/WebPage">

    <!-- Google Tag Manager -->
    <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-N8JP8G"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-N8JP8G');</script>
    <!-- End Google Tag Manager -->

		<div id="container">

			<header class="header" role="banner" itemscope itemtype="http://schema.org/WPHeader">

				<div id="inner-header" class="wrap cf">
          <ul id="links">
            <li><a href="https://www.algolia.com/jobs">Jobs</a></li>
            <li><a class="btn-primary" href="https://www.algolia.com/">Go to algolia.com</a></li>
          </ul>
          <a id="logo" href="/"><img src="https://www.algolia.com/static_assets/images/flat2/algolia/algolia-logo-45a5b66b.svg" width="130" alt="algolia"/></a>
										<p id="title" class="h1" itemscope itemtype="http://schema.org/Organization"><a href="https://blog.algolia.com" rel="nofollow">Milliseconds Matter</a></p>

										<p id="tagline">The Official Algolia Blog</p>


					<nav role="navigation" itemscope itemtype="http://schema.org/SiteNavigationElement">
						
					</nav>

				</div>

			</header>
			<div id="content">
				<div id="inner-content" class="wrap cf">

					<a class="single-back" href="#" onclick="goBack();">&lt;&nbsp;Back</a>

					<div id="search-input-wrapper" class="hide">
						<input id="search-input" placeholder="Search for posts, authors, ..." name="s" spellcheck="false"/>
					</div>

					<main id="main" class="d-all cf" role="main" itemscope itemprop="mainContentOfPage" itemtype="http://schema.org/Blog">

						<div class="algoliasearchcontainer hide"></div>
						<div class="post-content">
							
								
              
              <article id="post-5067" class="cf post-5067 post type-post status-publish format-standard has-post-thumbnail hentry category-technology" role="article" itemscope itemprop="blogPost" itemtype="http://schema.org/BlogPosting">

                <header class="article-header entry-header">

                  <h1 class="entry-title single-title" itemprop="headline" rel="bookmark">Inside the Algolia Engine Part 3 — Query Processing</h1>

                  <p class="byline entry-meta vcard">
                    <img class="author-avatar" src="https://secure.gravatar.com/avatar/25760a5d4e793e491f26da5db64bb738?s=96&d=mm&r=g" onerror="this.onerror=null;this.src='https://blog.algolia.com/wp-content/themes/algolia/library/images/avatar-algolia.png'" />
                    <span class="entry-author author" itemprop="author" itemscope itemptype="http://schema.org/Person">julien</span> |
                    <time class="updated entry-time" datetime="2016-05-24" itemprop="datePublished">May 24, 2016</time> |
                    <span class="entry-categories"><a href="https://blog.algolia.com/category/technology/" rel="category tag">Technology</a></span>
                  </p>

                                      <a href="https://blog.algolia.com/inside-the-algolia-engine-part-3-query-processing/" title="Inside the Algolia Engine Part 3 — Query Processing">
                    <img width="720" height="400" src="https://blog.algolia.com/wp-content/uploads/2016/05/inside-part-3.png" class="attachment-algolia-post-720 size-algolia-post-720 wp-post-image" alt="" srcset="https://blog.algolia.com/wp-content/uploads/2016/05/inside-part-3.png 720w, https://blog.algolia.com/wp-content/uploads/2016/05/inside-part-3-320x178.png 320w, https://blog.algolia.com/wp-content/uploads/2016/05/inside-part-3-340x189.png 340w" sizes="(max-width: 720px) 100vw, 720px" />                    </a>
                  
                </header> 
                <section class="entry-content cf" itemprop="articleBody">
                  <p class="lead"><span style="font-weight: 400;">Search engines and query processing are not recent in Computer Science: this field known as Information Retrieval has a pretty vast set of state of the art practices. Today most search engines on the market come with a large set of features that developers can use to create their query processing pipeline, but this task is far more difficult than it seems and most people never manage to achieve a good result. In this post, we will cover the classical approaches and how we are handling it in the Algolia engine.</span></p>
<h2><a id="introduction-to-query-processing" class="anchor" href="#introduction-to-query-processing" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Introduction to query processing</h2>
<p><span style="font-weight: 400;">To be able to find results, a search engine has to be able to understand deeply what was asked. That’s the role of the query processing: to analyse the query, and eventually transform it to make it easier to process by the search engine.</span></p>
<p><span style="font-weight: 400;">And to do so, a search engine will process the query in two big steps, both of which can be very challenging.</span></p>
<ol>
<li style="font-weight: 400;"><span style="font-weight: 400;">1) <strong>Detect words in the query</strong>: this process is called tokenization and identifies what is a word by answering questions like: <code>“is t-shirt one word or two?”</code></span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">2) <strong>Search for alternatives on this set of words</strong>: the goal of this step is to be less rigid by adding alternative corrections or synonyms, to avoid missing results that don’t contain exactly what was searched, but something equivalent. It decreases the need to reformulate the query to find what you want.</span></li>
<li style="font-weight: 400;">
<h2><a id="why-is-tokenization-complex" class="anchor" href="#why-is-tokenization-complex" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why is tokenization complex?</h2>
<p><span style="font-weight: 400;">The process of detecting words involves a set of rules to determine what is a word. It is applied both on the query and when indexing the words, to ensure both have the same format of words, which makes them easier to match.</span></p>
<p><span style="font-weight: 400;">This process seems simple at first – at least for alphabet-based languages – but as often, complexity creeps in when you consider the edge cases. And you soon realize that it’s way harder than it seemed, with no easy solutions.</span></p>
<p><span style="font-weight: 400;">To give you an idea of the complexity of tokenization, here is a non-exhaustive list of tokenization issues:</span></p>
<ul>
<li style="font-weight: 400;"><b>Symbols: </b><span style="font-weight: 400;">You cannot simply ignore symbols. C, C++ and C# are different words. And there are expressions that are composed of symbols only like the <a href="https://en.wikipedia.org/wiki/!!!">“!!!”</a> band!</span></li>
<li style="font-weight: 400;"><b>Compound words</b><span style="font-weight: 400;">: some languages like Dutch and German can aggregate words to form one expression. For example in Dutch, the word <code>"arbeidsongeschiktheidsverzekering"</code> means <code>"disability insurance"</code> and is composed of 3 words: arbeid (labour) + ongeschiktheid (inaptitude) + verzekering (insurance). Of course you would like to have a document containing this long expression match on the <code>"verzekering"</code> (insurance) query</span></li>
<li style="font-weight: 400;"><b>Agglutination</b><span style="font-weight: 400;">: some languages like Japanese, Chinese and Korean don’t  have separators between words (i.e. spaces). Those languages require a statistical approach that helps to detect words in the sequence of ideograms, the search engine also needs to be reliable to an error of word recognition. As with compound words, you want to be able to search for a document with just one of the words.</span></li>
<li style="font-weight: 400;"><b> Acronyms with Punctuation</b><span style="font-weight: 400;">: you want to find a record containing U.S.A with the USA query and vice versa</span></li>
<li style="font-weight: 400;"><b>Common words containing periods</b><span style="font-weight: 400;">: sometimes the period can have an importance like for domain names (.com, .net, .org), titles (mr., dr.) or abbreviations (st.)</span></li>
<li style="font-weight: 400;"><b>Hyphenated words</b><span style="font-weight: 400;">: the hyphen is not an easy case as it can be sometimes considered as a separator like in <code>"forty-two"</code> or <code>"San francisco-based"</code> but sometimes it is important like in <code>"pre-processing"</code></span></li>
<li style="font-weight: 400;"><b>Apostrophes</b><span style="font-weight: 400;">: they can be used for clitic contractions (we&#8217;re ⇒ we are), as genitive markers (Carl&#8217;s haircut) or as quotative markers</span></li>
<li style="font-weight: 400;"><b>CamelCase</b><span style="font-weight: 400;">: pretty common practice of writing compound words or phrases such that each word or abbreviation begins with a capital letter. You probably want to find your <code>"#AskGaryVee"</code> tag via the <code>"Gary Vee"</code> query</span></li>
<li style="font-weight: 400;"><b>Others</b><span style="font-weight: 400;">: HTML entities, dates, time, measures, phone numbers, etc.</span></li>
</ul>
<p><span style="font-weight: 400;">To know what to search for, the engine needs to know which words compose the query. But all of these exceptions make the process of detecting words pretty challenging. Not an easy problem to solve.</span></li>
</ol>
<h2><a id="why-is-searching-for-alternatives-also-complex" class="anchor" href="#why-is-searching-for-alternatives-also-complex" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why is searching for alternatives also complex?</h2>
<p><span style="font-weight: 400;">Once the query is tokenized, you have a set of words that will be searched in your documents. We will now enrich the query by searching for alternative words: by expanding the set of words we’ll be able to find matches that are close to the query but not exactly identical.</span></p>
<p><span style="font-weight: 400;">This process is only performed on the query and not when we index the record. (In a future post, we’ll explain why doing so on indexing is a bad idea.).</span></p>
<p>If you do not apply this process, you’ll have two problems:</p>
<ol>
<li style="font-weight: 400;"><span style="font-weight: 400;">1) You will miss some results if there is a small difference between the words in your records and the query (for example a singular versus plural). You can also have typos or errors in your query that cause those records to be unmatched.</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">2) The words in the record can be different than the query and lead to a different segmentation. For example, a record that contains &#8216;hispeed&#8217; will produce one token whereas the query &#8216;hi speed&#8217; will produce two tokens. This difference is pretty big as we cannot simply search for records containing the query terms anymore.</span></li>
</ol>
<p><span style="font-weight: 400;">That’s when it becomes complex. As you can see in this last example, searching for alternatives can potentially change the number of words in the query, which is always a bit of a mess to manage!</span></p>
<p><span style="font-weight: 400;">We can distinguish four different types of alternatives that can be added to expand the query:</span></p>
<ol>
<li style="font-weight: 400;">1)<b> An alternative word on a query word</b><span style="font-weight: 400;">: your query contains <code>"egg"</code> and your record contains <code>"eggs"</code>.</span></li>
<li style="font-weight: 400;">2)<b> A multi-word alternative on a query word</b><span style="font-weight: 400;">: your query contains <code>"NY"</code> and your record contains <code>"New York"</code> or if your query contains <code>"iphone"</code> and your record contains <code>"i phone"</code>.</span></li>
<li style="font-weight: 400;">3)<b> A word expression as alternative of several query words</b><span style="font-weight: 400;">: your query contains <code>"New York"</code> and you search for a record containing <code>"NY"</code> or if your query contains <code>"i phone"</code> and want to search for a record containing <code>"iphone"</code></span></li>
<li style="font-weight: 400;">4)<b> A multi-words expression as alternative of several query words</b><span style="font-weight: 400;">: this is the most complex one to handle, this is the case if you add a synonym set containing <code>['NY', 'New York', 'New York City']</code>. In this case, if your query is <code>"hotel new york city"</code>, it will be extended in:
<pre>
OR(AND("hotel","New York"),
   AND("hotel","NY"),
   AND("hotel","new","york"))
</pre>
</li>
</ol>
<p><span style="font-weight: 400;">The first type is properly handled in any search engine as it is just an OR between several terms but very few engines handle natively the last three cases which often require a lot of custom code.</span></p>
<h2><a id="algolia%e2%80%99s-way-of-tokenizing" class="anchor" href="#algolia%e2%80%99s-way-of-tokenizing" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Algolia’s way of tokenizing</h2>
<p><span style="font-weight: 400;">Our approach of tokenization was always to keep it as simple as possible. In the end, most challenges of tokenization can be solved via an alternative added at query time! That said, there are some cases which require a special processing at indexing time to be perfect:</span></p>
<ol>
<li style="font-weight: 400;">1)<b> Some abbreviation &amp; apostrophes</b><span style="font-weight: 400;">: If you have <code>"U.S.A"</code> in your record, it is very unlikely that you want to have it match for the query <code>"a"</code>. Which means you just want to have the token <code>"usa"</code> to avoid noise that could break the relevance. It is the same for the <code>"we're"</code> expression, in this case you just want to have one token. There are of course exceptions, for example <code>"l'hotel"</code> (French expression meaning <code>"the hotel"</code>) needs to be found as <code>"hotel"</code> and we do not want a token &#8220;lhotel&#8221;. All those cases are handled automatically by our engine without having to configure anything!</span></li>
<li style="font-weight: 400;">2)<b> Agglutinative languages</b><span style="font-weight: 400;">: For languages such as Chinese, Japanese and Korean we use a word dictionary with frequencies to split a sequence of ideograms in several tokens. We also detect the change of alphabet as a new token (this is useful, for example, in Japanese to produce a new token when we move from Hiragana to Kanji). All this processing is done automatically and we improve this segmentation all the time based on our user feedback.</span></li>
<li style="font-weight: 400;">3)<b> Symbols (&amp;, +, _ &#8230;)</b><span style="font-weight: 400;">: This part is the only one that is configurable since it depends on the use case and cannot be packaged in a generic way. We have a configuration setting to let you specify the symbols which are important for you. For example we used this approach on a website that helps students. They have to index mathematica formulas and make the difference between <code>"2x - 1"</code> and <code>"2x + 1"</code>. In this case we have indexed all mathematical symbols (addition, subtraction, multiplication, …)</span></li>
<li style="font-weight: 400;">4)<b> Compounded words and camel case</b><span style="font-weight: 400;">: A part of this processing has to be done at indexing if your record contains a compounded word like <code>"AskGaryVee"</code> and you want to be able to retrieve this record via the <code>"Gary Vee"</code> query. That’s the only step that we do not have today in production but which is on our roadmap. (You can expect to see this in the future!)</span></li>
</ol>
<p>At first sight, the process of tokenization can be perceived as simple. But as you have seen it is pretty complex in practice and requires quite a lot of work. We constantly work on improving it.</p>
<p>We only address a few of the tokenization challenges described at the beginning of this article. We actually solve most of them via alternatives added after tokenization. The next section describes those alternatives in details.<br />
<a name="alternatives"></a></p>
<h2><a id="algolia%e2%80%99s-way-of-searching-for-alternatives" class="anchor" href="#algolia%e2%80%99s-way-of-searching-for-alternatives" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Algolia’s way of searching for alternatives</h2>
<p><span style="font-weight: 400;">When we launched the engine in 2013, we had only typo tolerance as an alternative. But since then, we have improved the ability of the engine to find your records even with complex mistakes. </span></p>
<p><span style="font-weight: 400;">Today the engine expands a query via six different types of alternatives:</span></p>
<p><span style="font-weight: 400;">1) </span><b>Typo tolerance on words</b><span style="font-weight: 400;">: after tokenization, we look for potential approximations of each query word in the index dictionary (it contains all words used in this index). In practice, we compute a </span><a href="https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance"><span style="font-weight: 400;">Damerau-Levenshtein</span></a><span style="font-weight: 400;"> edit-distance between the query word and each word of the dictionary and accept the alternative if the number of typos is acceptable.</span></p>
<p><span style="font-weight: 400;">This Damerau-Levenshtein edit distance represents the number of letters inserted, deleted, substituted or transposed to change the query word to the dictionary word. For example the distance between <code>"mickael"</code> and <code>"mikcael"</code> is 1 as there is one transposition between <code>"ck"</code> and <code>"kc"</code> (transposition corresponds to a common typing mistake, two letter are inverted in the word).</span></p>
<p><span style="font-weight: 400;">In practice, we simplify the process. By looking at the maximum distance that is acceptable for each word, we apply a recursive scan on the dictionary (</span><a href="https://blog.algolia.com/inside-the-algolia-engine-part-2-the-indexing-challenge-of-instant-search/"><span style="font-weight: 400;">represented as a radix tree</span></a><span style="font-weight: 400;">). Then we prune the branches: optimizing the scan by re-evaluating on the fly what doesn’t need to be scanned. </span></p>
<p><span style="font-weight: 400;">By default we accept a maximum distance of 2 if the query word contains at least 8 letters and a maximum distance of 1 if the query word contains at least 4 letters (although those values are configurable).</span></p>
<p><span style="font-weight: 400;">Last but not least, the typo-tolerance function is able to correct a prefix, which is important in an instant search scenario. For example <code>"mikc"</code> will be considered as one typo of <code>"mick"</code> which is the prefix of <code>"mickael"</code> (In this case the dictionary does not contains the word <code>"mick"</code> but only the word <code>"mickael"</code>)</span></p>
<p><span style="font-weight: 400;">In our engine, typos are tolerated on words and prefix of words natively, without having to configure extra processes like ngram computation. This native approach has also the big advantage of being very efficient at indexing and producing an exact computation of relevance. You can learn more about the way we store our dictionary and prefixes in </span><a href="https://blog.algolia.com/inside-the-algolia-engine-part-2-the-indexing-challenge-of-instant-search/"><span style="font-weight: 400;">part 2</span></a><span style="font-weight: 400;"> of this series.</span></p>
<p><span style="font-weight: 400;">2) </span><b>Concatenation</b><span style="font-weight: 400;">: Typo tolerance on a tokenized query is already a challenge for performance but this is unfortunately not enough: the query tokenization can be different than the one performed at indexing time. This is the case if the query contains <code>"i phone"</code> and the record contains <code>"iphone"</code> and you would like to have an alternative with the concatenation of query terms! We automatically compute a concatenation for all pairs of terms plus a general concatenation of all the query terms. Which means, for example, that the query <code>"i phone case"</code> will generate the query:</p>
<pre>
OR(AND("i","phone","case"),
   AND("iphone","case"),
   AND("i","phonecase"),
   "iphonecase")
</pre>
<p><span style="font-weight: 400;">In order to avoid polluting the results by doing an approximation on an approximation, we do not apply typo tolerance on those new alternatives; they need to be identical in the dictionary. In this query the typo tolerance is only applied on each words of the <code>AND("i", "phone", "case")</code> part.</span></p>
<p><span style="font-weight: 400;">3)</span><b> Split of query tokens</b><span style="font-weight: 400;">: Concatenation is a very good added value of the engine but it unfortunately cannot catch all the cases. The word can be concatenated in the query and split in the record, and in this case you have no other choice than splitting the query term in several words. You have this issue if the query contains the hash tag #searchengine and your record contains <code>"search engine"</code>. The Algolia engine will automatically try to split all your query terms in two words using the dictionary. In this case we know the frequency of the &#8220;searchengine&#8221; term and the frequency of all possible splits. We look at all the possible ways to split the words and select the one that has the best score for </span><span style="font-weight: 400;"><code>min(freq(word1),freq(word2))</code></span><span style="font-weight: 400;">. In this case we take the best score between: </span><span style="font-weight: 400;"><code>min(freq(s), freq(earchengine))</code></span><span style="font-weight: 400;">, </span><span style="font-weight: 400;"><code>min(freq(se), freq(archengine))</code></span><span style="font-weight: 400;">,  … , </span><span style="font-weight: 400;"><code>min(freq(search), freq(engine))</code></span><span style="font-weight: 400;">, … , </span><span style="font-weight: 400;"><code>min(freq(searchengin), freq(e))</code></span><span style="font-weight: 400;">. It is obvious that the maximum will be obtained for the split in <code>"search"</code> + <code>"engine"</code> and we will extend the query term <code>"searchengine"</code> with a phrase query between <code>"search"</code> and <code>"engine"</code>. (Phrase query means that the terms <code>"engine"</code> need to be just after <code>"search"</code> in the record to match.)</span></p>
<p><span style="font-weight: 400;">4) </span><b>Transliteration</b><span style="font-weight: 400;">: All of the approaches we have described before work well for alphabet-based languages but can’t be applied on ideogram-based languages such as Chinese, Japanese and Korean. For these languages we use an extension file of the unicode standard called <code>"Unihan_variants"</code> that contains links between ideograms. For example those two lines contains a mapping between a simplified Chinese and traditional Chinese character:</span></p>
<blockquote><p>U+673A  kTraditionalVariant     U+6A5F</p>
<p><span style="font-weight: 400;">U+6A5F  kSimplifiedVariant      U+673A</span></p></blockquote>
<p><span style="font-weight: 400;">This unicode file also contains a </span><a href="https://en.wikipedia.org/wiki/Z-variant"><span style="font-weight: 400;">Z-variant</span></a><span style="font-weight: 400;"> of the same ideogram (share the same etymology but have slightly different appearances), for example:</span></p>
<blockquote><p><span style="font-weight: 400;">U+3588</span> <span style="font-weight: 400;">kZVariant</span> <span style="font-weight: 400;">U+439B</span></p>
<p><span style="font-weight: 400;">U+439B</span> <span style="font-weight: 400;">kZVariant</span> <span style="font-weight: 400;">U+3588</span></p></blockquote>
<p>The unicode format goes even further by containing ideogram with overlapping meanings, for example:</p>
<blockquote><p><span style="font-weight: 400;">U+349A</span> <span style="font-weight: 400;">kSemanticVariant</span> <span style="font-weight: 400;">U+7A69&lt;kFenn,kMatthews</span></p>
<p><span style="font-weight: 400;">U+349A</span> <span style="font-weight: 400;">kSpecializedSemanticVariant</span> <span style="font-weight: 400;">U+6587&lt;kFenn</span></p>
<p><span style="font-weight: 400;">U+6587</span> <span style="font-weight: 400;">kSpecializedSemanticVariant</span> <span style="font-weight: 400;">U+349A&lt;kFenn U+7A69&lt;kFenn</span></p>
<p><span style="font-weight: 400;">U+7A69</span> <span style="font-weight: 400;">kSemanticVariant</span> <span style="font-weight: 400;">U+349A&lt;kMatthews</span></p></blockquote>
<p><span style="font-weight: 400;">The engine will consider all those transliteration as one or two typo for ideogram-based languages. You will be able to search for simplified Chinese using a traditional Chinese query and vice versa!</span></p>
<p><span style="font-weight: 400;">5) </span><b>Lemmatisation</b><span style="font-weight: 400;">: Typo tolerance is pretty efficient in tolerating most differences between singular and plural forms. There are of course exceptions like <code>"city/cities"</code> or <code>"foot/feet"</code>. But the most important thing is that you probably don&#8217;t want to consider those small differences as a typo. This is why we have packaged a dictionary that contains singular/plurals form of words in 88 languages. This dictionary is called a lemmatizer and is exposed with the ignorePlural setting. You can simply add singular/plural alternatives without having to care about building such a resource.</span></p>
<p><span style="font-weight: 400;">6) </span><b>Synonyms: </b><span style="font-weight: 400;">The last type of alternative added in a query are synonyms. We have a pretty powerful synonym feature that handles all types of synonyms:</span></p>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">Add an alternative on a query term (the alternative can be a single word or a multi-word expression)</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Add an alternative on a multi-term query expression. The alternative can be a multi-word expression and can contain any number of words</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Add a placeholder token in your text that matches a list of words. You can, for example, add &lt;streetnumber&gt; in your record and configure it to match any numeric expression from 1 to 2000. Of course the record will not be found on the <code>"streetnumber"</code> query, but <code>“&lt;streetnumber&gt; Downing Street”</code> will be found for the query <code>“10 Downing Street”</code>.</span></li>
</ul>
<p><span style="font-weight: 400;">All those synonyms can be handled with a correct highlighting (<code>“iPhone”</code> will be correctly highlighted for the query <code>"iphine"</code>, despite the typo) with a correct handling of proximity between expressions. This part is pretty complex and not correctly handled by most engines, we will explain how we handle it in a future post!</span></p>
<p>We do not package synonyms with the engine. The reason is that synonyms are tightly linked to a domain and most of the time you just need a few of them to increase a lot the quality of your search. For example, I saw the synonym <code>"t-shirt"</code> = <code>"tee"</code> on several e-commerce website. This synonym makes sense as we see users typing <code>"tee"</code> to search for t-shirt, but it can be dangerous if you have sports articles (<code>"tee ball"</code> or <code>"gold tee"</code>).</p>
<p><span style="font-weight: 400;">The main issue behind that is the </span><a href="https://en.wikipedia.org/wiki/Polysemy"><span style="font-weight: 400;">polysemy</span></a><span style="font-weight: 400;"> of natural languages and the various specificities of each website. Our take is to handle automatically all the potential typos that few search engines handle automatically (like t-shirt = tshirt = t shirt) and use synonyms as a domain specific tuning you can perform to refine it when needed.</span></p>
<h2><a id="building-a-good-query-processing-takes-time" class="anchor" href="#building-a-good-query-processing-takes-time" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Building a good query processing takes time!</h2>
<p><span style="font-weight: 400;">We have built all those query processing steps over the last four years and of course new ones will come! Our first users only had typo tolerance at the beginning but they have seen the benefits of each improvement! Better: it did not have any negative impact on their relevance due to </span><a href="https://blog.algolia.com/how-algolia-tackled-the-relevance-problem-of-search-engines/"><span style="font-weight: 400;">our way of handling ranking</span></a><span style="font-weight: 400;">. We also managed to bring all those improvements without sacrificing performance! Before each added alternative, we have implemented a new optimization in the engine to counterbalance the cost of our alternatives!</span></p>
<p>We recommend to read the other posts of this series:</p>
<ul>
<li><a href="https://blog.algolia.com/inside-the-algolia-engine-part-1-indexing-vs-search/">Part 1 – indexing vs. search</a></li>
<li><a href="https://blog.algolia.com/inside-the-algolia-engine-part-2-the-indexing-challenge-of-instant-search/">Part 2 – the indexing challenge of instant search</a></li>
<li><a href="https://blog.algolia.com/inside-the-algolia-enginepart-4-textual-relevance/">Part 4 – Textual Relevance</a></li>
<li><a href="https://blog.algolia.com/inside-the-algolia-engine-part-5-highlighting-a-cornerstone-to-search-ux/">Part 5 – Highlighting, a Cornerstone of Search UX</a></li>
<li><a href="https://blog.algolia.com/inside-the-engine-part-6-handling-synonyms-the-right-way/">Part 6 – Handling Synonyms the Right Way</a></li>
<li><a href="https://blog.algolia.com/inside-the-engine-part-7-better-relevance-via-dedup-at-query-time/">Part 7 – Better relevance via dedup at query time</a></li>
</ul>
<!--www.crestaproject.com Social Button in Content Start--><div id="crestashareiconincontent" class="cresta-share-icon first_style"><div class="sbutton  facebook-cresta-share" id="facebook-cresta-c"><a rel="nofollow" href="https://www.facebook.com/sharer.php?u=https%3A%2F%2Fblog.algolia.com%2Finside-the-algolia-engine-part-3-query-processing%2F&amp;t=Inside+the+Algolia+Engine+Part+3+%E2%80%94+Query+Processing" title="Share to Facebook" onclick="window.open(this.href,'targetWindow','toolbars=0,location=0,status=0,menubar=0,scrollbars=1,resizable=1,width=640,height=320,left=200,top=200');return false;"><i class="cs c-icon-cresta-facebook"></i></a></div><div class="sbutton  twitter-cresta-share" id="twitter-cresta-c"><a rel="nofollow" href="https://twitter.com/share?text=Inside+the+Algolia+Engine+Part+3+%E2%80%94+Query+Processing&amp;url=https%3A%2F%2Fblog.algolia.com%2Finside-the-algolia-engine-part-3-query-processing%2F&amp;via=algolia" title="Share to Twitter" onclick="window.open(this.href,'targetWindow','toolbars=0,location=0,status=0,menubar=0,scrollbars=1,resizable=1,width=640,height=320,left=200,top=200');return false;"><i class="cs c-icon-cresta-twitter"></i></a></div><div class="sbutton  linkedin-cresta-share" id="linkedin-cresta-c"><a rel="nofollow" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A%2F%2Fblog.algolia.com%2Finside-the-algolia-engine-part-3-query-processing%2F&amp;title=Inside+the+Algolia+Engine+Part+3+%E2%80%94+Query+Processing&amp;source=https://blog.algolia.com/" title="Share to LinkedIn" onclick="window.open(this.href,'targetWindow','toolbars=0,location=0,status=0,menubar=0,scrollbars=1,resizable=1,width=640,height=320,left=200,top=200');return false;"><i class="cs c-icon-cresta-linkedin"></i></a></div><div style="clear: both;"></div></div><div style="clear: both;"></div><!--www.crestaproject.com Social Button in Content End-->                </section> 
                <!-- <footer class="article-footer">


                </footer>-->
                
                
<div id="disqus_thread">
            <div id="dsq-content">


            <ul id="dsq-comments">
                    <li class="comment even thread-even depth-1" id="dsq-comment-504">
        <div id="dsq-comment-header-504" class="dsq-comment-header">
            <cite id="dsq-cite-504">
                <span id="dsq-author-user-504">Hal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-504" class="dsq-comment-body">
            <div id="dsq-comment-message-504" class="dsq-comment-message"><p>Are there any cases where &#8220;3) Split of query tokens&#8221; is not what the user wants? e.g. User searches for a rare term, but the rare term is split into 2 more frequent terms.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-505">
        <div id="dsq-comment-header-505" class="dsq-comment-header">
            <cite id="dsq-cite-505">
                <a id="dsq-author-user-505" href="http://www.algolia.com/" target="_blank" rel="nofollow">Julien Lemoine</a>
            </cite>
        </div>
        <div id="dsq-comment-body-505" class="dsq-comment-body">
            <div id="dsq-comment-message-505" class="dsq-comment-message"><p>This is something we handle as the form with one token is matching exactly (exact=1 in our ranking formula) and the form with two words does not match exactly (exact=0). So you will always have your rare term first. That said, this is a very rare case to have a rare term that is just the concatenation of two frequent terms that are exactly close together in the text (because we match them via a phrase query).</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
            </ul>


        </div>

    </div>

                                                  
              </article> 
							
													</div>

						<section id="subscribe-newsletter" class="cf">
    <div id="mc4wp-form-1" class="form mc4wp-form">
        <form action="https://go.pardot.com/l/139121/2016-06-09/f3kzm" method="post" role="form" lpformnum="1">
            <p>
                <input type="email" id="mc4wp_email" name="email" placeholder="Your email address" required="">
            </p>
            <p>
                <input type="submit" value="Sign up">
            </p>
        </form>
    </div>
</section>

					</main>

					
				</div>

			</div>

			<footer class="footer" role="contentinfo" itemscope itemtype="http://schema.org/WPFooter">

				<div id="inner-footer" class="wrap cf">

          <a class="footer-logo" href="https://www.algolia.com">
            <img src="https://www.algolia.com/static_assets/images/flat2/algolia/algolia-logo-45a5b66b.svg" width="150" alt="algolia"/>
          </a>

          <p class="footer-tagline">We make instant and relevant search.<br>
          Easy for developers, delightful for the users.
          <p>

          <ul class="social-links">
            <li><a class="social-twitter" href="https://twitter.com/algolia"><i class="icon-twitter"></i></a></li>
            <li><a class="social-googleplus" href="https://plus.google.com/+Algolia"><i class="icon-google-plus"></i></a></li>
            <li><a class="social-facebook" href="https://www.facebook.com/algolia"><i class="icon-facebook2"></i></a></li>
            <li><a class="social-linkedin" href="https://www.linkedin.com/company/algolia"><i class="icon-linkedin2"></i></a></li>
            <li><a class="social-github" href="https://github.com/Algolia"><i class="icon-github2"></i></a></li>
          </ul>

					<p class="source-org copyright">&copy;Algolia - <a href="https://www.algolia.com/policies/privacy">Privacy Policy</a></p>

				</div>

			</footer>

		</div>

				<script type="text/template" id="autocomplete-template">
    <div class="result">
        <div class="title">
            {{#featureImage}}
            <img style="width: 30px" src="{{{ featureImage.sizes.thumbnail.file }}}" />
            {{/featureImage}}
            {{{ _highlightResult.title.value }}}
        </div>
    </div>
</script>

<script type="text/template" id="instant-content-template">
    <div class="search-sorting">
        <span class="label">Sort by</span>
        <select id="index_to_use">
            <option {{#sortSelected}}{{relevance_index_name}}{{/sortSelected}} value="{{relevance_index_name}}">Relevance</option>
            {{#sorting_indices}}
            <option {{#sortSelected}}{{index_name}}{{/sortSelected}} value="{{index_name}}">{{label}}</option>
            {{/sorting_indices}}
        </select>
    </div>
    <div class="cf spacer20"></div>
    <div class="hits-wrapper">
      {{#hits}}
          {{^query}}
              <div class="d-1of3 t-1of2" algolia-object-id="{{ objectID }}">
                  <article class="grid-entry grid-entry--columns">
                      <header class="article-header">
                          <a href="{{permalink}}"><img class="entry-illus" src="{{featureImage.sizes.medium.file}}"/></a>
                          <h1 class="h3 entry-title"><a href="{{permalink}}">{{{ _highlightResult.title.value }}}</a></h1>
                      </header>
                  </article>
              </div>
          {{/query}}

          {{#query}}
            <article class="grid-entry grid-entry--detailled" algolia-object-id="{{ objectID }}">
                <div class="d-1of3 t-1of3">
                    <a href="{{permalink}}"><img class="entry-illus" src="{{featureImage.sizes.medium.file}}"/></a>
                </div>
                <div class="d-2of3 t-2of3">
                    <h1 class="h3 entry-title"><a href="{{permalink}}">{{{ _highlightResult.title.value }}}</a></h1>

                    <span class="entry-author" data-tax="author" data-name="{{ author }}" >
                        <img class="author-avatar" src="{{ avatar_url }}" onerror="this.onerror=null;this.style.border='1px solid rgb(0, 164, 255)';this.src='/wp-content/themes/algolia/library/images/avatar-algolia.png'"/>
                        {{{ _highlightResult.author.value }}}
                    </span>
                    <span class="entry-date">{{#getDate}}{{date}}{{/getDate}}</span>
                    <p class="entry-desc">...{{{ _snippetResult.content.value }}}...</p>

                    <ul class="tags">
                    {{#_highlightResult.post_tag}}
                        <li class="match-{{matchLevel}}">{{{value}}}</li>
                    {{/_highlightResult.post_tag}}
                    </ul>
                </div>
                <div class="cf"></div>
            </article>
          {{/query}}

      {{/hits}}
    </div>
    {{^hits.length}}
    <div class="no-result">
      <div>No posts nor authors matched your query <strong>{{ query }}</strong>.</div>
      <div><a href="#" class="clear-button">clear search</a></div>
    </div>
    {{/hits.length}}
</script>


<script type="text/template" id="instant-facets-template">
    {{#facets}}
    {{#count}}
    <div class="search-filters {{tax}}">
        {{#facet_categorie_name}}
            <span class="label">
                {{ facet_categorie_name }}
            </span>
        {{/facet_categorie_name}}
        <ul>
            {{#sub_facets}}

                {{#type.conjunctive}}
                <li class="{{#checked}} checked {{/checked}} sub_facet conjunctive related-tag {{#hidden}} hide {{/hidden}}">
                    <input style="display: none;" data-tax="{{tax}}" {{#checked}} checked {{/checked}} data-name="{{name}}" class="facet_value" type="checkbox" />
                    {{name}}
                </li>
                {{/type.conjunctive}}

                {{#type.disjunctive}}
                <li class="{{#checked}} checked {{/checked}} sub_facet disjunctive">
                    <input style="display: none;" data-tax="{{tax}}" {{#checked}} checked {{/checked}} data-name="{{name}}" class="facet_value" type="checkbox" />
                    {{name}} {{#count}}({{count}}){{/count}}
                </li>
                {{/type.disjunctive}}

                {{#type.menu}}
                <li data-tax="{{tax}}" data-name="{{nameattr}}" data-type="menu" class="{{#checked}}checked {{/checked}}sub_facet disjunctive menu {{#category}}category{{/category}}">
                    <input style="display: none;" data-tax="{{tax}}" {{#checked}}checked{{/checked}} data-name="{{nameattr}}" class="facet_value" type="checkbox" />
                    {{name}} {{#print_count}}{{#count}}<span class="facet-count">{{count}}</span>{{/count}}{{/print_count}}
                </li>
                {{/type.menu}}

            {{/sub_facets}}
        </ul>
    </div>
    {{/count}}
    {{/facets}}
</script>



<script type="text/template" id="instant-pagination-template">
    <div class="pagination-wrapper cf">
        <ul class="pagination">
            <li {{^prev_page}}class="disabled"{{/prev_page}}>
                <a href="#" data-page="{{prev_page}}">
                    Previous
                </a>
            </li>

            {{#pages}}
            <li class="{{#current}}active{{/current}}{{#disabled}}disabled{{/disabled}}">
                <a href="#" data-page="{{number}}">
                    {{ number }}
                </a>
            </li>
            {{/pages}}

            <li {{^next_page}}class="disabled"{{/next_page}}>
                <a href="#" data-page="{{next_page}}">
                    Next
                </a>
            </li>
        </ul>
    </div>
</script>
<!--www.crestaproject.com Social Button Floating Start--><div id="crestashareicon" class="cresta-share-icon  first_style "><div class="sbutton  facebook-cresta-share float" id="facebook-cresta"><a rel="nofollow" href="https://www.facebook.com/sharer.php?u=https%3A%2F%2Fblog.algolia.com%2Finside-the-algolia-engine-part-3-query-processing%2F&amp;t=Inside+the+Algolia+Engine+Part+3+%E2%80%94+Query+Processing" title="Share to Facebook" onclick="window.open(this.href,'targetWindow','toolbars=0,location=0,status=0,menubar=0,scrollbars=1,resizable=1,width=640,height=320,left=200,top=200');return false;"><i class="cs c-icon-cresta-facebook"></i></a></div><div class="sbutton  twitter-cresta-share float noCount" id="twitter-cresta"><a rel="nofollow" href="https://twitter.com/share?text=Inside+the+Algolia+Engine+Part+3+%E2%80%94+Query+Processing&amp;url=https%3A%2F%2Fblog.algolia.com%2Finside-the-algolia-engine-part-3-query-processing%2F&amp;via=algolia" title="Share to Twitter" onclick="window.open(this.href,'targetWindow','toolbars=0,location=0,status=0,menubar=0,scrollbars=1,resizable=1,width=640,height=320,left=200,top=200');return false;"><i class="cs c-icon-cresta-twitter"></i></a></div><div class="sbutton  linkedin-cresta-share float" id="linkedin-cresta"><a rel="nofollow" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A%2F%2Fblog.algolia.com%2Finside-the-algolia-engine-part-3-query-processing%2F&amp;title=Inside+the+Algolia+Engine+Part+3+%E2%80%94+Query+Processing&amp;source=https://blog.algolia.com/" title="Share to LinkedIn" onclick="window.open(this.href,'targetWindow','toolbars=0,location=0,status=0,menubar=0,scrollbars=1,resizable=1,width=640,height=320,left=200,top=200');return false;"><i class="cs c-icon-cresta-linkedin"></i></a></div><div style="clear: both;"></div></div>

<!--www.crestaproject.com Social Button Floating End-->
<link rel='stylesheet' id='hljstheme-css'  href='https://blog.algolia.com/wp-content/plugins/wp-code-highlightjs/styles/monokai-sublime.css' type='text/css' media='all' />
<script type='text/javascript' src='https://blog.algolia.com/wp-content/plugins/cresta-social-share-counter/js/jquery.cresta-social-effect.js'></script>
<script type='text/javascript' src='https://s0.wp.com/wp-content/js/devicepx-jetpack.js'></script>
<script type='text/javascript' src='https://blog.algolia.com/wp-includes/js/comment-reply.min.js'></script>
<script type='text/javascript' src='https://blog.algolia.com/wp-content/themes/algolia/library/js/scripts.js'></script>
<script type='text/javascript' src='https://blog.algolia.com/wp-includes/js/wp-embed.min.js'></script>
<script type='text/javascript' src='https://blog.algolia.com/wp-content/plugins/wp-code-highlightjs/highlight.common.pack.js'></script>
<script type='text/javascript' src='https://blog.algolia.com/wp-content/plugins/wp-code-highlightjs/highlight.custom.pack.js'></script>
<script type='text/javascript'>
/* <![CDATA[ */
var embedVars = {"disqusConfig":{"platform":"wordpress@4.7.5","language":""},"disqusIdentifier":"5067 https:\/\/blog.algolia.com\/?p=5067","disqusShortname":"algoliablog","disqusTitle":"Inside the Algolia Engine Part 3 \u2014 Query Processing","disqusUrl":"https:\/\/blog.algolia.com\/inside-the-algolia-engine-part-3-query-processing\/","options":{"manualSync":false},"postId":"5067"};
/* ]]> */
</script>
<script type='text/javascript' src='https://blog.algolia.com/wp-content/plugins/disqus-comment-system/media/js/disqus.js'></script>
<script type='text/javascript'>
/* <![CDATA[ */
var countVars = {"disqusShortname":"algoliablog"};
/* ]]> */
</script>
<script type='text/javascript' src='https://blog.algolia.com/wp-content/plugins/disqus-comment-system/media/js/count.js'></script>
    <style>pre.hljs {padding: 5px;}
pre.hljs code {}
pre code.hljs { background: none; } </style>
    <script type="text/javascript">
    (function($, window) {
        var init_fn_flag = false;
        var init_fn = (function() {
            if (init_fn_flag)
                return;
            init_fn_flag = true;
             hljs.configure({"tabReplace":"    "});
            $('pre code').each(function(i, block) {
                hljs.highlightBlock(block);
            });
        });
        $(document).ready(init_fn);
        $(window).on("load", init_fn);
    })(jQuery, window);
    </script>
<script type='text/javascript' src='https://stats.wp.com/e-201721.js' async defer></script>
<script type='text/javascript'>
	_stq = window._stq || [];
	_stq.push([ 'view', {v:'ext',j:'1:4.7.1',blog:'116008343',post:'5067',tz:'-7',srv:'blog.algolia.com'} ]);
	_stq.push([ 'clickTrackerInit', '116008343', '5067' ]);
</script>

	</body>

</html> <!-- end of site. what a ride! -->
